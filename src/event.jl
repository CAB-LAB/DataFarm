"""
Define abstract type for the distrubance, each subtype should define the method
genEvent(d::Event,Nlon,Nlat,Ntime)
"""
abstract Event
export Event
outevent!(ev::Event,x)=x

"""
This function generates a 3D Array of Ntime, Nlat, Nlon. It should `= 0` for all points that are not affected by an event and `> 0`
for affected grid cells. In the simplest case the resulting array is binary (either 0 or 1)
"""
genEvent(d::Event,Ntime,Nlat,Nlon)=error("The method genEvent is not defined for $(typeof(d))")


"""
n simple cubic disturbances of relative sizes sx,sy,sz (0..1) for each event with the centers at px,py,pz (0..1) for each event
The positions and sizes are relative to the cube size
"""
type CubeEvent <: Event
    n::Int
    sx::Vector{Float64}
    sy::Vector{Float64}
    sz::Vector{Float64}
    px::Vector{Float64}
    py::Vector{Float64}
    pz::Vector{Float64}
end
export CubeEvent
export genEvent
function genEvent(d::CubeEvent,Ntime,Nlat,Nlon)
    sx=d.sx*Nlon/2-0.5;px=d.px*(Nlon+1)
    sy=d.sy*Nlat/2-0.5;py=d.py*(Nlat+1)
    sz=d.sz*Ntime/2-0.5;pz=d.pz*(Ntime+1)
    # First check that disturbance fits into the cube
    a = zeros(Float64,Ntime,Nlat,Nlon)
    for i=1:d.n
        a[max(1,round(Int,pz[i]-sz[i])):min(Ntime,round(Int,pz[i]+sz[i])),max(1,round(Int,py[i]-sy[i])):min(Nlat,round(Int,py[i]+sy[i])),max(1,round(Int,px[i]-sx[i])):min(Nlon,round(Int,px[i]+sx[i]))]+=1
    end
    a
end
# Some convenience Constructors to create centered disturbances of a certain size
CubeEvent(s::AbstractFloat) = CubeEvent(1,[s],[s],[s],[0.5],[0.5],[0.5])

function CubeEvent(n::Integer,sx::Number,sy::Number,sz::Number)
    sx=fill(convert(Float64,sx),n)
    sy=fill(convert(Float64,sy),n)
    sz=fill(convert(Float64,sz),n)
    px=Float64[i/(n+1) for i=1:n]
    py=Float64[i/(n+1) for i=1:n]
    pz=Float64[i/(n+1) for i=1:n]
    CubeEvent(n,sx,sy,sz,px,py,pz)
end



"""
simple local distrubance that covers a single longitude-latitude point (0..1,0..1) over the time span s (0..1) starting at time t (0..1)
"""
type LocalEvent <: Event
    xlon::Float64
    xlat::Float64
    s   ::Float64
    t   ::Float64
end
export LocalEvent
function genEvent(d::LocalEvent,Ntime,Nlat,Nlon)
    sx = round(Int,d.xlon*Nlon)
    sy = round(Int,d.xlat*Nlat)
    tstart = round(Int,d.s*Ntime+0.5)
    tend   = tstart+round(Int,d.t*Ntime+0.5)-1
    a = zeros(Float64,Ntime,Nlat,Nlon)
    a[tstart:tend,sx,sy]=1
    a
end


"Type for an empty Disturbance"
type EmptyEvent <: Event
end
export EmptyEvent
genEvent(d::EmptyEvent,Ntime,Nlat,Nlon)=zeros(Int,Ntime,Nlat,Nlon)



"Gaussian disturbance, no sharp edegs. This is constructed by supplying a center px,py,pz and bandwidth sx,sy,sz"
type GaussianEvent
    sx::Float64
    sy::Float64
    sz::Float64
    px::Float64
    py::Float64
    pz::Float64
end
export GaussianEvent
GaussianEvent(s::Number)=GaussianEvent(s,s,s,0.5,0.5,0.5)
function genEvent(d::GaussianEvent,Ntime,Nlat,Nlon)
    sx=d.sx*Nlon/2-0.5;px=d.px*(Nlon+1)
    sy=d.sy*Nlat/2-0.5;py=d.py*(Nlat+1)
    sz=d.sz*Ntime/2-0.5;pz=d.pz*(Ntime+1)
    a=[exp((i-px)^2/sx^2 + (j-py)^2/sy^2) + (k-pz)^2/sz^2 for k=1:Ntime,j=1:Nlat,i=1:Nlon]
end

"""
This is a wrapper type that generates trend-like events in time. It wraps a given event `ev` which is usually a step
function and integrates it in the time domain to obtain slowly changing behaviour.
"""
type TrendEvent{T<:Event} <: Event
    ev::T
    persist::Bool
end
export TrendEvent
function genEvent(d::TrendEvent,Ntime,Nlat,Nlon)
    #First generate innner event
    a = genEvent(d.ev,Ntime,Nlat,Nlon)
    #Integrate over time
    d.persist ? cumsum!(a,a,1) : cumsumcontinous!(a)
    #If trend increase does not persist, set event to 0 after extreme
    #And rescale
    scale!(a,1./maximum(a))
    a
end
function outevent!(ev::TrendEvent,x)
    for ilon=1:size(x,3), ilat=1:size(x,2), itime=size(x,1):-1:2
        x[itime,ilat,ilon]=x[itime,ilat,ilon]-x[itime-1,ilat,ilon]
        x[itime,ilat,ilon]<0.0 && (x[itime,ilat,ilon]=0.0)
    end
    scale!(x,1/maximum(x))
    x
end

function cumsumcontinous!(a)
    for x in 1:size(a,3), y in 1:size(a,2), z in 2:size(a,1)
        if a[z,y,x]>0.0
            a[z,y,x]+=a[z-1,y,x]
        end
    end
end


"This generates an event of spatial size sx,sy at px,py that starts at time os and lasts until the end of the time series"
type OnsetEvent <: Event
    sx::Float64
    sy::Float64
    px::Float64
    py::Float64
    os::Float64
end
export OnsetEvent
function genEvent(d::OnsetEvent,Ntime,Nlat,Nlon)
    sx=d.sx*Nlon/2-0.5;px=d.px*(Nlon+1)
    sy=d.sy*Nlat/2-0.5;py=d.py*(Nlat+1)
    pz=d.os*(Ntime+1)
    # FIrst check that disturbance fits into the cube
    a = zeros(Float64,Ntime,Nlat,Nlon)
    a[round(Int,pz):Ntime,round(Int,py-sy):round(Int,py+sy),round(Int,px-sx):round(Int,px+sx)]=1
    a
end

"RandomWalkEvent, generates N events. The event is generated by doing a Random Walk in 3D crossing starting at px,py,pz. with step probabilities px,py,pz in the respective directions"
type RandomWalkEvent <: Event
    n::Int
    sx::Vector{Float64}
    sy::Vector{Float64}
    sz::Vector{Float64}
    px::Vector{Float64}
    py::Vector{Float64}
    pz::Vector{Float64}
end
export RandomWalkEvent
function RandomWalkEvent(n::Integer,sx::Number,sy::Number,sz::Number)
    sx=fill(convert(Float64,sx),n);sy=fill(convert(Float64,sy),n);sz=fill(convert(Float64,sz),n);px=Float64[i/(n+1) for i=1:n];py=Float64[i/(n+1) for i=1:n];pz=Float64[i/(n+1) for i=1:n];
    RandomWalkEvent(n,sx,sy,sz,px,py,pz)
end
function genEvent(d::RandomWalkEvent,Ntime,Nlat,Nlon)
    sx=d.sx*Nlon;px=iround(d.px*(Nlon+1))
    sy=d.sy*Nlat;py=iround(d.py*(Nlat+1))
    sz=d.sz*Ntime;pz=iround(d.pz*(Ntime+1))
    a = zeros(Float64,Ntime,Nlat,Nlon)
    for ievent=1:d.n
        walkweights=[sx[ievent]^2,sx[ievent]^2,sy[ievent]^2,sy[ievent]^2,sz[ievent]^2,sz[ievent]^2]
        scale!(walkweights,1/sum(walkweights))
        distri=Categorical(walkweights)
        Ntot=iround(sx[ievent]*sy[ievent]*sz[ievent])
        x=px[ievent];y=py[ievent];z=pz[ievent]
        a[z,y,x]=1 #Set starting point to 1
        itot=1
        while itot<Ntot
            direc = rand(distri)
            (direc == 1) && (x=max(1,x-1))
            (direc == 2) && (x=min(Nlon,x+1))
            (direc == 3) && (y=max(1,y-1))
            (direc == 4) && (y=min(Nlat,y+1))
            (direc == 5) && (z=max(1,z-1))
            (direc == 6) && (z=min(Ntime,z+1))
            if a[z,y,x]==0
                a[z,y,x]=1
                itot=itot+1
            end
        end
    end
    a
end
